<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<title>Scofield Analista - Padr√µes Branco</title>
<style>
  body { font-family: Arial, sans-serif; background: #fff; color: #000; padding: 20px; }
  label, select, input { margin: 5px 0; display: block; }
  button { margin-top: 10px; padding: 10px 20px; cursor: pointer; border-radius: 5px; border: none; font-weight: bold; }
  .vermelho { background: #c0392b; color: white; }
  .preto { background: #000; color: white; }
  .branco { background: #ecf0f1; color: #000; border: 1px solid #ccc; }
  #log { margin-top: 20px; max-height: 220px; overflow-y: auto; background: #eee; padding: 10px; }
  #prediction { margin-top: 20px; font-weight: bold; }
</style>
</head>
<body>

<h1>Scofield Analista - Padr√µes Branco</h1>

<form id="dataForm">
  <label>Hor√°rio (HH:MM): <input type="time" id="horario" required></label>

  <fieldset>
    <legend>Pedra 1</legend>
    <label>Cor:
      <select id="cor1" required>
        <option value="">Selecione</option>
        <option value="vermelho">Vermelho</option>
        <option value="preto">Preto</option>
        <option value="branco">Branco</option>
      </select>
    </label>
    <label>N√∫mero:
      <input type="number" id="num1" min="0" max="14" required>
    </label>
    <label>
      Branco nesta pedra?
      <select id="branco1" required>
        <option value="nao">N√£o</option>
        <option value="sim">Sim</option>
      </select>
    </label>
  </fieldset>

  <fieldset>
    <legend>Pedra 2</legend>
    <label>Cor:
      <select id="cor2" required>
        <option value="">Selecione</option>
        <option value="vermelho">Vermelho</option>
        <option value="preto">Preto</option>
        <option value="branco">Branco</option>
      </select>
    </label>
    <label>N√∫mero:
      <input type="number" id="num2" min="0" max="14" required>
    </label>
    <label>
      Branco nesta pedra?
      <select id="branco2" required>
        <option value="nao">N√£o</option>
        <option value="sim">Sim</option>
      </select>
    </label>
  </fieldset>

  <button type="submit" class="vermelho">Adicionar Resultado</button>
</form>

<div id="log"></div>
<div id="prediction"></div>

<script>
  const dataForm = document.getElementById('dataForm');
  const logDiv = document.getElementById('log');
  const predictionDiv = document.getElementById('prediction');

  let results = JSON.parse(localStorage.getItem('results')) || [];

  // Fun√ß√£o para formatar hor√°rio para minutos corridos desde 00:00
  function timeToMinutes(t) {
    const [h, m] = t.split(':').map(Number);
    return h * 60 + m;
  }

  // Fun√ß√£o para converter minutos para HH:MM
  function minutesToTime(min) {
    const h = Math.floor(min / 60) % 24;
    const m = min % 60;
    return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
  }

  function updateLog() {
    if (results.length === 0) {
      logDiv.innerHTML = '<p>Nenhum resultado ainda.</p>';
      return;
    }
    logDiv.innerHTML = '';
    results.forEach((r, i) => {
      const pedra1 = `${emojiCor(r.cor1)} ${r.num1} ${r.branco1==='sim'?'‚ö™':''}`;
      const pedra2 = `${emojiCor(r.cor2)} ${r.num2} ${r.branco2==='sim'?'‚ö™':''}`;
      logDiv.innerHTML += `<div><strong>${r.horario}</strong>: Pedra 1 - ${pedra1} | Pedra 2 - ${pedra2}</div>`;
    });
  }

  // Retorna emoji para cor
  function emojiCor(cor) {
    if (cor === 'vermelho') return 'üî¥';
    if (cor === 'preto') return '‚ö´';
    if (cor === 'branco') return '‚ö™';
    return '';
  }

  // Detectar padr√µes Duplo, Dentado, Banguela
  function detectarPadroes() {
    let mensagens = [];

    // Criar lista s√≥ com os minutos onde saiu branco (em qual pedra e qual minuto)
    const brancos = [];
    results.forEach((r,i) => {
      if(r.branco1 === 'sim') brancos.push({ index:i, pedra:1 });
      if(r.branco2 === 'sim') brancos.push({ index:i, pedra:2 });
    });

    // Detectar Duplo (branco seguido no minuto seguinte)
    for(let i=0; i < brancos.length -1; i++) {
      if(brancos[i+1].index === brancos[i].index + 1) {
        mensagens.push(`Duplo detectado nos minutos ${results[brancos[i].index].horario} e ${results[brancos[i+1].index].horario}`);
      }
    }

    // Detectar Dentado (branco - qualquer pedra - branco em 3 minutos consecutivos)
    for(let i=0; i < brancos.length -2; i++) {
      if(brancos[i+1].index === brancos[i].index + 1 && brancos[i+2].index === brancos[i].index + 2) {
        mensagens.push(`Dentado detectado entre os minutos ${results[brancos[i].index].horario}, ${results[brancos[i+1].index].horario} e ${results[brancos[i+2].index].horario}`);
      }
    }

    // Detectar Banguela (brancos separados por at√© 3 pedras (ou seja, at√© 1 minuto e meio))
    for(let i=0; i < brancos.length -1; i++) {
      const diferenca = brancos[i+1].index - brancos[i].index;
      if(diferenca > 1 && diferenca <= 3) {
        mensagens.push(`Banguela detectada entre os minutos ${results[brancos[i].index].horario} e ${results[brancos[i+1].index].horario}`);
      }
    }

    return mensagens;
  }

  // Calcula a m√©dia dos intervalos entre brancos para previs√£o
  function mediaIntervaloBranco() {
    const brancosIndices = [];
    results.forEach((r,i) => {
      if(r.branco1 === 'sim' || r.branco2 === 'sim') brancosIndices.push(i);
    });
    if(brancosIndices.length < 2) return null;
    let somaIntervalos = 0;
    for(let i=1; i < brancosIndices.length; i++) {
      somaIntervalos += (brancosIndices[i] - brancosIndices[i-1]);
    }
    return somaIntervalos / (brancosIndices.length -1);
  }

  // Prever pr√≥ximo branco e avisar 5 minutos antes
  function preverBranco() {
    const media = mediaIntervaloBranco();
    if(media === null) {
      predictionDiv.textContent = 'Dados insuficientes para previs√£o.';
      return null;
    }

    // √öltimo branco
    let ultimoBrancoIndex = -1;
    for(let i=results.length -1; i>=0; i--) {
      if(results[i].branco1 === 'sim' || results[i].branco2 === 'sim') {
        ultimoBrancoIndex = i;
        break;
      }
    }
    if(ultimoBrancoIndex === -1) {
      predictionDiv.textContent = 'Nenhum branco registrado ainda.';
      return null;
    }

    const previstoIndex = Math.round(ultimoBrancoIndex + media);
    const atualIndex = results.length - 1;
    const falta = previstoIndex - atualIndex;

    let msg = `Pr√≥ximo branco previsto para ${previstoIndex >= results.length ? 'futuro pr√≥ximo' : 'minuto ' + results[previstoIndex]?.horario || previstoIndex}`;

    if(falta <= 5 && falta > 0) {
      msg += ` (Faltam ${falta} minuto(s))`;
      playAlert();
    }
    predictionDiv.textContent = msg;
    return { falta };
  }

  // Alerta sonoro simples
  function playAlert() {
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const oscillator = audioCtx.createOscillator();
    oscillator.type = 'square';
    oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
    oscillator.connect(audioCtx.destination);
    oscillator.start();
    oscillator.stop(audioCtx.currentTime + 0.5);
  }

  // Intervalo para checar previs√£o e alertas a cada 5 segundos
  setInterval(() => {
    preverBranco();
    const padroes = detectarPadroes();
    if(padroes.length > 0) {
      predictionDiv.innerHTML += '<br>‚ö†Ô∏è Padr√µes detectados:<br>' + padroes.join('<br>');
    }
  }, 5000);

  dataForm.addEventListener('submit', e => {
    e.preventDefault();
    const entry = {
      horario: document.getElementById('horario').value,
      cor1: document.getElementById('cor1').value,
      num1: Number(document.getElementById('num1').value),
      branco1: document.getElementById('branco1').value,
      cor2: document.getElementById('cor2').value,
      num2: Number(document.getElementById('num2').value),
      branco2: document.getElementById('branco2').value
    };
    results.push(entry);
    localStorage.setItem('results', JSON.stringify(results));
    updateLog();
    preverBranco();
    dataForm.reset();
  });

  // Inicializar tela
  updateLog();
  preverBranco();
</script>

</body>
</html>
