<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scofield Analista PRO Avan√ßado</title>
  <style>
    body {
      background: #111;
      color: #eee;
      font-family: 'Segoe UI', sans-serif;
      padding: 15px;
      max-width: 480px;
      margin: auto;
    }
    h1 {
      text-align: center;
      color: #ff4747;
      margin-bottom: 10px;
    }
    textarea,
    input,
    button {
      width: 100%;
      padding: 10px;
      margin: 5px 0;
      border-radius: 5px;
      box-sizing: border-box;
      font-size: 1em;
      font-family: monospace;
    }
    textarea,
    input {
      background: #222;
      color: #eee;
      border: 1px solid #555;
      resize: vertical;
    }
    button {
      background: #ff4747;
      color: white;
      border: none;
      cursor: pointer;
      font-weight: bold;
      transition: background 0.3s ease;
    }
    button:hover {
      background: #e53e3e;
    }
    .secao {
      margin-top: 25px;
    }
    .sinal {
      background: #222;
      padding: 10px;
      margin-top: 10px;
      border-radius: 5px;
      font-size: 1em;
    }
    .sinal button {
      width: 48%;
      margin: 2px 1%;
      font-weight: bold;
    }
    .estatisticas {
      white-space: pre-line;
      background: #222;
      padding: 10px;
      border-radius: 5px;
      margin-top: 15px;
      font-size: 0.9em;
      max-height: 140px;
      overflow-y: auto;
    }
    #mensagemCerebro,
    #mensagemHistorico,
    #mensagemAnalise {
      margin-top: 10px;
      color: #8f8;
      font-weight: bold;
      min-height: 22px;
    }
    .status-aviso {
      color: #ff4747;
      font-weight: bold;
      margin-top: 5px;
      font-size: 0.9em;
    }
    .label-count {
      font-size: 0.9em;
      color: #aaa;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <h1>Scofield Analista PRO Avan√ßado ‚ö™</h1>

  <div class="secao">
    <h3>üß† Hist√≥rico C√©rebro (cole todo o hist√≥rico completo para aprendizado)</h3>
    <textarea
      id="historicoCerebro"
      rows="10"
      placeholder="Formato exemplo: n√∫mero, hor√°rio com segundos em linhas alternadas. Exemplo:
3
02:12:42
2
14
02:12:12
..."></textarea>
    <button onclick="enviarCerebro()">üì§ Enviar Hist√≥rico</button>
    <div id="mensagemCerebro"></div>
    <div class="label-count" id="countEstrategias">0 estrat√©gias criadas</div>
  </div>

  <div class="secao">
    <h3>‚è±Ô∏è Hist√≥rico para An√°lise (√∫ltimas jogadas para prever o pr√≥ximo branco)</h3>
    <textarea
      id="historicoAtual"
      rows="6"
      placeholder="Cole aqui as √∫ltimas pedras com hor√°rio para analisar"></textarea>
    <button onclick="analisarAgora()">üîç Analisar</button>
    <div id="mensagemAnalise" class="status-aviso"></div>
    <div id="previsoes"></div>
  </div>

  <div class="secao">
    <h3>üìä Estat√≠sticas de Resultados</h3>
    <div id="estatisticas" class="estatisticas"></div>
    <button onclick="limparEstatisticas()">üßπ Limpar Estat√≠sticas</button>
  </div>

  <div class="secao">
    <h3>üßπ Limpar Campos de Hist√≥rico e An√°lise</h3>
    <button onclick="limparHistorico()">üßº Limpar Campos</button>
    <div id="mensagemHistorico"></div>
  </div>

  <script>
    // ---------- STORAGE ----------
    let estrategias = JSON.parse(localStorage.getItem("estrategias") || "[]");
    let estatisticas = JSON.parse(localStorage.getItem("estatisticas") || "[]");

    // ---------- CONSTANTES ----------
    // Branco definido como n√∫mero >= 10 (ajuste se quiser)
    const BRANCO_MIN_NUMERO = 10;
    // Quantidade m√≠nima para aceitar hist√≥rico
    const MIN_TAMANHO_HISTORICO = 8;
    // Per√≠odos do dia para an√°lise
    const PERIODOS_DIA = [
      { nome: "Madrugada", inicio: 0, fim: 5 },
      { nome: "Manh√£", inicio: 6, fim: 11 },
      { nome: "Tarde", inicio: 12, fim: 17 },
      { nome: "Noite", inicio: 18, fim: 23 },
    ];

    // ---------- UTILIT√ÅRIOS ----------

    // Parse do hist√≥rico em formato linhas pares √≠mpares (n√∫mero, hor√°rio)
    // Retorna array de objetos {numero: number|null, horario: Date}
    function parseHistorico(texto) {
      const linhas = texto.trim().split("\n").map(l => l.trim()).filter(l => l !== "");
      const pedras = [];
      for (let i = 0; i < linhas.length; i += 2) {
        let numRaw = linhas[i];
        let horarioRaw = linhas[i + 1];
        if (!horarioRaw) continue;
        let numero = parseInt(numRaw);
        if (isNaN(numero)) numero = null;
        const horario = parseHorario(horarioRaw);
        if (!horario) continue;
        pedras.push({ numero, horario });
      }
      return pedras;
    }

    // Parse hor√°rio no formato hh:mm:ss e retorna Date hoje com aquele hor√°rio
    function parseHorario(str) {
      const regex = /^(\d{1,2}):(\d{2}):(\d{2})$/;
      const m = str.match(regex);
      if (!m) return null;
      const now = new Date();
      now.setHours(parseInt(m[1], 10));
      now.setMinutes(parseInt(m[2], 10));
      now.setSeconds(parseInt(m[3], 10));
      now.setMilliseconds(0);
      return new Date(now);
    }

    // Fun√ß√£o que determina se √© branco pelo n√∫mero
    function ehBranco(pedra) {
      return pedra.numero !== null && pedra.numero >= BRANCO_MIN_NUMERO;
    }

    // Formata Date para hh:mm:ss
    function formatHorario(date) {
      return date.toTimeString().slice(0, 8);
    }

    // Fun√ß√£o para calcular diferen√ßa em segundos entre duas datas
    function diffSegundos(a, b) {
      return Math.abs((a.getTime() - b.getTime()) / 1000);
    }

    // Fun√ß√£o para somar segundos a uma data e retornar nova data
    function somarSegundos(data, segundos) {
      return new Date(data.getTime() + segundos * 1000);
    }

    // ---------- ESTRAT√âGIAS ----------

    /* 
    Estrat√©gia: detectar sequ√™ncias de 3 pedras: anterior, branco, posterior
    Guardar padr√£o: n√∫meros anterior e posterior + intervalo m√©dio dos brancos
    */

    function extrairEstrategias(pedras) {
      let novas = 0;
      for (let i = 1; i < pedras.length - 1; i++) {
        const anterior = pedras[i - 1];
        const atual = pedras[i];
        const posterior = pedras[i + 1];
        if (!ehBranco(atual)) continue;

        // Criar padr√£o: combina√ß√£o n√∫meros anterior e posterior
        const padrao = {
          anterior: anterior.numero,
          posterior: posterior.numero,
          // intervalo m√©dio entre brancos ser√° atualizado depois
          intervalos: [],
          horarios: [],
        };

        // Verificar se padr√£o j√° existe
        let estrategiaExistente = estrategias.find((e) => 
          e.anterior === padrao.anterior && e.posterior === padrao.posterior
        );

        if (!estrategiaExistente) {
          // Nova estrat√©gia
          padrao.horarios.push(atual.horario.getTime());
          estrategias.push(padrao);
          novas++;
        } else {
          // Atualizar estrat√©gia existente: adicionar hor√°rio se n√£o tiver igual
          if (!estrategiaExistente.horarios.includes(atual.horario.getTime())) {
            estrategiaExistente.horarios.push(atual.horario.getTime());
            novas++;
          }
        }
      }
      calcularIntervalos();
      atualizarEstrategiasCount();
      return novas;
    }

    // Calcular intervalos m√©dios para cada estrat√©gia
    function calcularIntervalos() {
      estrategias.forEach((e) => {
        e.intervalos = [];
        e.horarios.sort((a, b) => a - b);
        for (let i = 1; i < e.horarios.length; i++) {
          e.intervalos.push((e.horarios[i] - e.horarios[i - 1]) / 1000);
        }
        e.mediaIntervalo = e.intervalos.length > 0 ? 
          e.intervalos.reduce((a, b) => a + b, 0) / e.intervalos.length : 0;
      });
    }

    // Buscar estrat√©gia por padr√£o (anterior e posterior)
    function buscarEstrategia(anterior, posterior) {
      return estrategias.find((e) => e.anterior === anterior && e.posterior === posterior);
    }

    // ---------- PREVIS√ÉO ----------

    // Gerar previs√µes avan√ßadas baseadas no hist√≥rico atual e estrat√©gias aprendidas
    function gerarPrevisoesAvancadas(pedras) {
      const previsoes = [];
      // Analisar as √∫ltimas pedras (ideal 3 pedras para formar padr√£o)
      if (pedras.length < 3) return previsoes;

      const ultima = pedras[pedras.length - 2]; // pen√∫ltima pedra (anterior)
      const atual = pedras[pedras.length - 1];  // √∫ltima pedra (posterior)

      if (!ultima || !atual) return previsoes;
      if (!ultima.numero || !atual.numero) return previsoes;

      // Tentar achar estrat√©gia que combine com padr√£o (anterior, posterior)
      const estrategia = buscarEstrategia(ultima.numero, atual.numero);

      if (estrategia && estrategia.mediaIntervalo > 0) {
        // Usar m√©dia dos intervalos para prever pr√≥ximo branco
        // O pr√≥ximo branco esperado ser√° a partir do √∫ltimo hor√°rio conhecido + m√©diaIntervalo

        // Pega o √∫ltimo hor√°rio conhecido da estrat√©gia
        const ultimoHorarioTimestamp = Math.max(...estrategia.horarios);
        const ultimoHorario = new Date(ultimoHorarioTimestamp);

        // Calcula o pr√≥ximo hor√°rio previsto
        const proximoHorario = somarSegundos(ultimoHorario, estrategia.mediaIntervalo);

        previsoes.push({
          horario: formatHorario(proximoHorario),
          nivel: "Forte",
          estrategia,
        });
      }

      // Se n√£o achar padr√£o, usar m√©dia simples dos brancos recentes para prever pr√≥ximo
      if (previsoes.length === 0) {
        // Calcular m√©dia dos intervalos entre brancos recentes
        const brancos = pedras.filter(ehBranco).sort((a, b) => a.horario - b.horario);
        if (brancos.length < 2) return previsoes;
        let intervalos = [];
        for (let i = 1; i < brancos.length; i++) {
          intervalos.push(diffSegundos(brancos[i].horario, brancos[i - 1].horario));
        }
        const mediaIntervalo = intervalos.reduce((a, b) => a + b, 0) / intervalos.length;
        const ultimoBranco = brancos[brancos.length - 1];
        const proximoHorario = somarSegundos(ultimoBranco.horario, mediaIntervalo);
        previsoes.push({
          horario: formatHorario(proximoHorario),
          nivel: "Moderado",
          estrategia: null,
        });
      }

      // Ajuste final para evitar hor√°rios no passado (se der, soma mais um intervalo)
      previsoes.forEach((p) => {
        const agora = new Date();
        const [h, m, s] = p.horario.split(":").map(Number);
        let dataPrev = new Date(agora);
        dataPrev.setHours(h, m, s, 0);
        if (dataPrev < agora) {
          dataPrev = somarSegundos(dataPrev, 60); // adiciona 1 minuto
          p.horario = formatHorario(dataPrev);
        }
      });

      return previsoes;
    }

    // ---------- FEEDBACK ----------

    // Registrar resultado (acertou/errou) para ajustar estat√≠sticas e peso das estrat√©gias
    function registrarResultado(horario, resultado) {
      estatisticas.push({ horario, resultado: resultado === "win" ? "‚úÖ" : "‚ùå", data: new Date().toISOString() });
      salvarDados();
    }

    // ---------- ESTAT√çSTICAS ----------

    function atualizarEstatisticas() {
      const div = document.getElementById("estatisticas");
      if (estatisticas.length === 0) {
        div.innerText = "Nenhum resultado registrado ainda.";
        return;
      }
      div.innerText = estatisticas
        .map((e) => `${e.data.slice(0, 19).replace("T", " ")} - ${e.horario} ${e.resultado}`)
        .reverse()
        .join("\n");
    }

    // Atualiza contador vis√≠vel de estrat√©gias
    function atualizarEstrategiasCount() {
      document.getElementById("countEstrategias").innerText = `${estrategias.length} estrat√©gias criadas`;
    }

    // ---------- LIMPEZAS ----------

    function limparEstatisticas() {
      if (confirm("Tem certeza que deseja apagar as estat√≠sticas?")) {
        estatisticas = [];
        salvarDados();
      }
    }

    function limparHistorico() {
      document.getElementById("historicoCerebro").value = "";
      document.getElementById("historicoAtual").value = "";
      document.getElementById("mensagemCerebro").innerText = "";
      document.getElementById("mensagemAnalise").innerText = "";
      document.getElementById("previsoes").innerHTML = "";
      document.getElementById("mensagemHistorico").innerText = "‚úÖ Campos de hist√≥rico limpos! Estrat√©gias mantidas.";
    }

    // ---------- SALVAR E CARREGAR ----------

    function salvarDados() {
      localStorage.setItem("estrategias", JSON.stringify(estrategias));
      localStorage.setItem("estatisticas", JSON.stringify(estatisticas));
      atualizarEstatisticas();
      atualizarEstrategiasCount();
    }

    // ---------- FUN√á√ïES PRINCIPAIS ----------

    function enviarCerebro() {
      const texto = document.getElementById("historicoCerebro").value;
      if (texto.trim().length < MIN_TAMANHO_HISTORICO) {
        alert("Hist√≥rico muito curto.");
        return;
      }
      const pedras = parseHistorico(texto);
      if (pedras.length === 0) {
        alert("N√£o foi poss√≠vel reconhecer o hist√≥rico. Formato incorreto?");
        return;
      }
      const novasEstrategias = extrairEstrategias(pedras);
      if (novasEstrategias > 0) {
        document.getElementById("mensagemCerebro").innerText = `‚úÖ Hist√≥rico analisado com sucesso! ${novasEstrategias} novas estrat√©gias criadas.`;
      } else {
        document.getElementById("mensagemCerebro").innerText = "‚úÖ Hist√≥rico analisado! Nenhuma nova estrat√©gia detectada.";
      }
      salvarDados();
    }

    function analisarAgora() {
      const texto = document.getElementById("historicoAtual").value;
      if (texto.trim().length < 10) {
        alert("Hist√≥rico para an√°lise muito curto.");
        return;
      }
      const pedras = parseHistorico(texto);
      if (pedras.length === 0) {
        alert("N√£o foi poss√≠vel reconhecer o hist√≥rico de an√°lise. Formato incorreto?");
        return;
      }
      const previsoes = gerarPrevisoesAvancadas(pedras);
      const div = document.getElementById("previsoes");
      div.innerHTML = "";
      if (previsoes.length === 0) {
        div.innerHTML = "<p>üîç Nenhum padr√£o. Usando previs√£o simples:</p>";
        return;
      }
      document.getElementById("mensagemAnalise").innerText = "";
      previsoes.forEach((p) => {
        const sinalDiv = document.createElement("div");
        sinalDiv.className = "sinal";
        sinalDiv.innerHTML = `
          <strong>${p.horario}</strong> (${p.nivel})<br>
          <button onclick="registrarResultado('${p.horario}', 'win')">‚úÖ Acertou</button>
          <button onclick="registrarResultado('${p.horario}', 'loss')">‚ùå Errou</button>
        `;
        div.appendChild(sinalDiv);
      });
    }

    // Inicializa√ß√£o
    salvarDados();
  </script>
</body>
</html>
