<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scofield Analista PRO V2 ‚ö™</title>
  <style>
    body {
      background: #111;
      color: #eee;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      padding: 15px;
    }
    h1 {
      text-align: center;
      color: #ff4747;
      margin-bottom: 0;
    }
    textarea, input, button {
      width: 100%;
      padding: 10px;
      margin: 5px 0;
      border-radius: 5px;
      box-sizing: border-box;
      font-size: 1em;
    }
    textarea, input {
      background: #222;
      color: #eee;
      border: 1px solid #555;
      font-family: monospace;
      resize: vertical;
    }
    button {
      background: #ff4747;
      color: white;
      border: none;
      cursor: pointer;
      font-weight: bold;
      transition: background-color 0.3s ease;
    }
    button:hover {
      background: #e53e3e;
    }
    .secao {
      margin-top: 25px;
    }
    .sinal {
      background: #222;
      padding: 10px;
      margin-top: 10px;
      border-radius: 5px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
    }
    .sinal strong {
      flex: 1 1 auto;
      font-size: 1.1em;
    }
    .sinal button {
      width: 48%;
      margin: 5px 1%;
      font-weight: bold;
    }
    .estatisticas, .desempenho {
      white-space: pre-line;
      background: #222;
      padding: 10px;
      border-radius: 5px;
      margin-top: 15px;
      font-size: 1em;
      max-height: 200px;
      overflow-y: auto;
    }
    .info {
      margin-top: 6px;
      font-weight: bold;
      color: #8bc34a;
      font-size: 1em;
    }
  </style>
</head>
<body>
  <h1>Scofield Analista PRO V2 ‚ö™</h1>

  <div class="secao">
    <h3>üß† Hist√≥rico C√©rebro (Aprendizado geral)</h3>
    <textarea id="historicoCerebro" rows="8" placeholder="Cole aqui o hist√≥rico completo com hor√°rios, n√∫meros e cores..."></textarea>
    <button onclick="enviarCerebro()">üì§ Enviar Hist√≥rico</button>
    <div id="mensagemCerebro" class="info"></div>
    <div><strong>Estrat√©gias criadas:</strong> <span id="numEstrategias">0</span></div>
    <button onclick="limparHistoricoCerebro()" style="background:#555; margin-top:8px;">üßπ Limpar Hist√≥rico C√©rebro (mant√©m estrat√©gias)</button>
  </div>

  <div class="secao">
    <h3>‚è±Ô∏è Hist√≥rico Atual (Para prever pr√≥ximos brancos)</h3>
    <textarea id="historicoAtual" rows="6" placeholder="Cole aqui as √∫ltimas jogadas para prever os brancos..."></textarea>
    <button onclick="analisarAgora()">üîç Analisar</button>
    <div id="previsoes"></div>
    <button onclick="limparHistoricoAtual()" style="background:#555; margin-top:8px;">üßπ Limpar Hist√≥rico Atual</button>
  </div>

  <div class="secao">
    <h3>üìä Estat√≠sticas de Resultados</h3>
    <div id="estatisticas" class="estatisticas"></div>
    <button onclick="limparEstatisticas()" style="background:#555; margin-top:8px;">üßπ Limpar Estat√≠sticas</button>
  </div>

  <div class="secao">
    <h3>üìà Desempenho da M√°quina</h3>
    <div id="desempenho" class="desempenho">Nenhuma previs√£o feita ainda.</div>
  </div>

  <div class="secao">
    <h3>üîß Entrada Manual de Pedras (Pedra anterior / Branco / Pedra posterior)</h3>
    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
      <div style="flex:1;">
        <label><strong>Pedra Anterior (N√∫mero)</strong></label>
        <input type="number" id="pedraAnteriorNumero" min="1" max="14" placeholder="Ex: 5" />
        <label><strong>Hor√°rio (HH:MM:SS)</strong></label>
        <input type="text" id="pedraAnteriorHorario" placeholder="Ex: 12:34:56" pattern="\d{2}:\d{2}:\d{2}" />
      </div>
      <div style="flex:1;">
        <label><strong>Branco (Hor√°rio apenas)</strong></label>
        <input type="text" id="brancoHorario" placeholder="Ex: 12:35:56" pattern="\d{2}:\d{2}:\d{2}" />
      </div>
      <div style="flex:1;">
        <label><strong>Pedra Posterior (N√∫mero)</strong></label>
        <input type="number" id="pedraPosteriorNumero" min="1" max="14" placeholder="Ex: 7" />
        <label><strong>Hor√°rio (HH:MM:SS)</strong></label>
        <input type="text" id="pedraPosteriorHorario" placeholder="Ex: 12:36:26" pattern="\d{2}:\d{2}:\d{2}" />
      </div>
    </div>
    <button onclick="analisarManual()" style="margin-top:10px;">üîç Analisar Padr√£o Manual</button>
    <div id="resultadoManual" class="info"></div>
  </div>

  <script>
    // --- Dados armazenados ---
    let estrategias = JSON.parse(localStorage.getItem("estrategias") || "[]");
    let estatisticas = JSON.parse(localStorage.getItem("estatisticas") || "[]");
    let totalPrevisoes = parseInt(localStorage.getItem("totalPrevisoes") || "0");
    let totalAcertos = parseInt(localStorage.getItem("totalAcertos") || "0");
    let totalErros = parseInt(localStorage.getItem("totalErros") || "0");

    // Fun√ß√£o utilit√°ria para parse de hor√°rio HH:MM:SS -> segundos desde 00:00:00
    function horarioParaSegundos(horario) {
      const [h, m, s] = horario.split(":").map(Number);
      return h * 3600 + m * 60 + s;
    }

    // Fun√ß√£o utilit√°ria para converter segundos para hor√°rio HH:MM:SS
    function segundosParaHorario(seg) {
      const h = Math.floor(seg / 3600) % 24;
      const m = Math.floor((seg % 3600) / 60);
      const s = seg % 60;
      return `${String(h).padStart(2,"0")}:${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
    }

    // Fun√ß√£o utilit√°ria para detectar per√≠odo do dia
    function periodoDoDia(horario) {
      const [h] = horario.split(":").map(Number);
      if (h >= 6 && h < 12) return "Manh√£";
      if (h >= 12 && h < 18) return "Tarde";
      if (h >= 18 && h < 24) return "Noite";
      return "Madrugada";
    }

    // Atualiza contador vis√≠vel de estrat√©gias criadas
    function atualizarNumEstrategias() {
      document.getElementById("numEstrategias").innerText = estrategias.length;
    }

    // --- Fun√ß√£o principal para enviar o hist√≥rico c√©rebro ---
    function enviarCerebro() {
      const texto = document.getElementById("historicoCerebro").value.trim();
      if (texto.length < 10) {
        alert("Hist√≥rico muito curto.");
        return;
      }
      // Aqui simulamos aprendizado detalhado:  
      // O texto √© processado e gera m√∫ltiplas estrat√©gias baseadas em padr√µes detectados (simplificado)
      // Estrat√©gias: { id, periodo, tempoMedio, frequenciaMinuto, score }
      // Para facilitar, vamos extrair todos os hor√°rios dos brancos e calcular tempo m√©dio e padr√£o de minutos

      // Extrair brancos do texto (exemplo: linhas contendo "branco" ou pedra 0 ou aus√™ncia de n√∫mero)
      // Aqui simplificado para exemplo: toda linha que n√£o tem n√∫mero ser√° ignorada, e as que tiverem n√∫mero ser√£o parseadas
      // Voc√™ pode adaptar a an√°lise conforme seu formato real

      // Simula√ß√£o simplificada para criar uma estrat√©gia
      const linhas = texto.split("\n").filter(l => l.trim());
      let brancos = [];

      // Exemplo simples: linhas que tem "branco" ou sem n√∫mero
      for(let i=0; i<linhas.length; i++){
        const linha = linhas[i].toLowerCase();
        if(linha.includes("branco") || linha.trim()===""){
          // tentamos pegar o hor√°rio da linha anterior (ex: linha i-1)
          if(i>0){
            let anterior = linhas[i-1];
            let horarioMatch = anterior.match(/\d{2}:\d{2}:\d{2}/);
            if(horarioMatch){
              brancos.push(horarioMatch[0]);
            }
          }
        } else {
          // se tiver hor√°rio e n√∫mero, tenta extrair o hor√°rio
          let horarioMatch = linha.match(/\d{2}:\d{2}:\d{2}/);
          if(horarioMatch){
            // Pode ser pedra com n√∫mero, ignorado pra estrat√©gia simples
          }
        }
      }
      // Se n√£o pegou brancos, tenta extrair qualquer hor√°rio com pedra igual a 0 (simula√ß√£o)
      if(brancos.length === 0){
        for(let linha of linhas){
          if(linha.includes("0")){
            let horarioMatch = linha.match(/\d{2}:\d{2}:\d{2}/);
            if(horarioMatch){
              brancos.push(horarioMatch[0]);
            }
          }
        }
      }

      // Calcular tempo m√©dio entre brancos por per√≠odo do dia
      let temposPorPeriodo = {};
      for(let i=1; i<brancos.length; i++){
        const prev = horarioParaSegundos(brancos[i-1]);
        const curr = horarioParaSegundos(brancos[i]);
        const diff = curr - prev > 0 ? curr - prev : (24*3600 - prev + curr); // conta virada meia-noite

        const periodo = periodoDoDia(brancos[i]);
        if(!temposPorPeriodo[periodo]) temposPorPeriodo[periodo] = [];
        temposPorPeriodo[periodo].push(diff);
      }

      // M√©dia ponderada do tempo por per√≠odo
      let novasEstrategias = [];
      for(let periodo in temposPorPeriodo){
        const tempos = temposPorPeriodo[periodo];
        if(tempos.length < 1) continue;
        let soma = tempos.reduce((a,b) => a+b, 0);
        let media = Math.round(soma / tempos.length);

        // Criar estrat√©gia
        novasEstrategias.push({
          id: Date.now() + Math.random(),
          periodo,
          tempoMedio: media,
          frequenciaMinuto: {}, // pode ser preenchido depois com an√°lise mais complexa
          score: 1
        });
      }

      // Adiciona ao array global e salva
      estrategias = estrategias.concat(novasEstrategias);
      salvarDados();

      document.getElementById("mensagemCerebro").innerText = 
        `‚úÖ Hist√≥rico analisado com sucesso! ${novasEstrategias.length} estrat√©gias criadas.`;

      atualizarNumEstrategias();
    }

    // --- Fun√ß√£o para analisar o hist√≥rico atual e gerar 2 previs√µes ---
    function analisarAgora() {
      const texto = document.getElementById("historicoAtual").value.trim();
      if(texto.length < 10){
        alert("Cole o hist√≥rico atual para an√°lise.");
        return;
      }

      // Extrair hor√°rio atual
      const agora = new Date();
      const periodoAtual = periodoDoDia(segundosParaHorario(agora.getHours()*3600 + agora.getMinutes()*60 + agora.getSeconds()));

      // Pegar estrat√©gias do per√≠odo atual, ordenadas por score
      const estrategiasPeriodo = estrategias.filter(e => e.periodo === periodoAtual);
      if(estrategiasPeriodo.length === 0){
        alert(`Nenhuma estrat√©gia dispon√≠vel para o per√≠odo ${periodoAtual}.`);
        return;
      }
      estrategiasPeriodo.sort((a,b) => b.score - a.score);

      // Escolher as duas estrat√©gias com maior score
      const melhores = estrategiasPeriodo.slice(0,2);

      // Gerar as previs√µes exatas baseadas no tempo m√©dio da estrat√©gia
      // Pegamos o √∫ltimo hor√°rio do hist√≥rico colado para basear a previs√£o
      let ultLinha = texto.trim().split("\n").pop();
      let ultHorarioMatch = ultLinha.match(/\d{2}:\d{2}:\d{2}/);
      if(!ultHorarioMatch){
        alert("N√£o foi poss√≠vel detectar hor√°rio na √∫ltima linha do hist√≥rico atual.");
        return;
      }
      let ultHorarioSeg = horarioParaSegundos(ultHorarioMatch[0]);

      // Previs√µes: tempo m√©dio ap√≥s √∫ltimo branco (assumindo branco est√° na √∫ltima linha)
      let previsoes = melhores.map(e => {
        let segPrev = ultHorarioSeg + e.tempoMedio;
        segPrev = segPrev % (24*3600);
        // Verificar se ser√° duplo ou dentado (simples heur√≠stica)
        let tipo = "Normal";
        if(e.tempoMedio < 150) tipo = "Duplo";
        else if(e.tempoMedio > 240) tipo = "Dentado";

        return {
          horario: segundosParaHorario(segPrev),
          nivel: e.score >= 3 ? "Forte" : e.score === 2 ? "Moderado" : "Arriscado",
          tipo
        };
      });

      // Mostrar previs√µes
      const div = document.getElementById("previsoes");
      div.innerHTML = "<h4>üü¢ Pr√≥ximos brancos previstos:</h4>";
      previsoes.forEach(p => {
        const sinalDiv = document.createElement("div");
        sinalDiv.className = "sinal";
        sinalDiv.innerHTML = `
          <strong>${p.horario}</strong> (${p.nivel}) - Tipo: <em>${p.tipo}</em><br>
          <button onclick="registrarResultado('${p.horario}','win')">‚úÖ Acertou</button>
          <button onclick="registrarResultado('${p.horario}','loss')">‚ùå Errou</button>
        `;
        div.appendChild(sinalDiv);
      });
    }

    // --- Registrar resultado acerto/erro e atualizar pontua√ß√£o da melhor estrat√©gia ---
    function registrarResultado(horario, resultado) {
      estatisticas.push({ horario, resultado: resultado === 'win' ? '‚úÖ' : '‚ùå' });
      totalPrevisoes++;
      if(resultado === 'win') totalAcertos++;
      else totalErros++;

      // Atualiza score das estrat√©gias mais prov√°veis para esse hor√°rio
      // Aqui simplificado para ajustar a estrat√©gia do per√≠odo atual mais alta
      const periodoAtual = periodoDoDia(horario);
      let estrategia = estrategias.filter(e => e.periodo === periodoAtual).sort((a,b) => b.score - a.score)[0];
      if(estrategia){
        if(resultado === 'win') estrategia.score++;
        else estrategia.score = Math.max(1, estrategia.score - 1);
      }
      salvarDados();
      atualizarDesempenho();
      atualizarEstatisticas();
      alert(`Resultado "${resultado === 'win' ? 'Acertou' : 'Errou'}" registrado para ${horario}.`);
    }

    // --- Atualizar estat√≠sticas vis√≠veis ---
    function atualizarEstatisticas() {
      const div = document.getElementById("estatisticas");
      div.innerText = estatisticas.slice(-50).map(e => `${e.horario} ${e.resultado}`).reverse().join("\n");
    }

    // --- Atualizar painel de desempenho ---
    function atualizarDesempenho() {
      const div = document.getElementById("desempenho");
      const taxa = totalPrevisoes === 0 ? 0 : ((totalAcertos / totalPrevisoes) * 100).toFixed(2);
      div.innerText = `Total Previs√µes: ${totalPrevisoes}\nAcertos: ${totalAcertos}\nErros: ${totalErros}\nTaxa de acerto: ${taxa}%`;
    }

    // --- Limpar estat√≠sticas ---
    function limparEstatisticas() {
      if(confirm("Tem certeza que deseja apagar as estat√≠sticas?")) {
        estatisticas = [];
        totalPrevisoes = 0;
        totalAcertos = 0;
        totalErros = 0;
        salvarDados();
        atualizarDesempenho();
        atualizarEstatisticas();
      }
    }

    // --- Limpar hist√≥rico c√©rebro, mant√©m estrat√©gias ---
    function limparHistoricoCerebro() {
      if(confirm("Limpar hist√≥rico c√©rebro? Estrat√©gias ser√£o mantidas.")) {
        document.getElementById("historicoCerebro").value = "";
        document.getElementById("mensagemCerebro").innerText = "";
      }
    }

    // --- Limpar hist√≥rico atual ---
    function limparHistoricoAtual() {
      if(confirm("Limpar hist√≥rico atual?")) {
        document.getElementById("historicoAtual").value = "";
        document.getElementById("previsoes").innerHTML = "";
      }
    }

    // --- Salvar dados no localStorage ---
    function salvarDados() {
      localStorage.setItem("estrategias", JSON.stringify(estrategias));
      localStorage.setItem("estatisticas", JSON.stringify(estatisticas));
      localStorage.setItem("totalPrevisoes", totalPrevisoes);
      localStorage.setItem("totalAcertos", totalAcertos);
      localStorage.setItem("totalErros", totalErros);
      atualizarNumEstrategias();
    }

    // --- Fun√ß√£o para analisar manualmente entrada de pedras ---
    function analisarManual() {
      const pedraAntNum = parseInt(document.getElementById("pedraAnteriorNumero").value);
      const pedraAntHor = document.getElementById("pedraAnteriorHorario").value;
      const brancoHor = document.getElementById("brancoHorario").value;
      const pedraPosNum = parseInt(document.getElementById("pedraPosteriorNumero").value);
      const pedraPosHor = document.getElementById("pedraPosteriorHorario").value;

      if(!pedraAntNum || !pedraAntHor || !brancoHor || !pedraPosNum || !pedraPosHor){
        alert("Preencha todos os campos para an√°lise manual.");
        return;
      }
      // Exemplo simplificado: calcula intervalo entre pedras e tenta prever pr√≥ximo branco baseado no padr√£o
      const segPedraAnt = horarioParaSegundos(pedraAntHor);
      const segBranco = horarioParaSegundos(brancoHor);
      const segPedraPos = horarioParaSegundos(pedraPosHor);

      const intervaloAntBranco = segBranco - segPedraAnt > 0 ? segBranco - segPedraAnt : (24*3600 - segPedraAnt + segBranco);
      const intervaloBrancoPos = segPedraPos - segBranco > 0 ? segPedraPos - segBranco : (24*3600 - segBranco + segPedraPos);

      const intervaloMedio = Math.round((intervaloAntBranco + intervaloBrancoPos) / 2);

      let previsaoSeg = segBranco + intervaloMedio;
      previsaoSeg = previsaoSeg % (24*3600);
      let previsaoHor = segundosParaHorario(previsaoSeg);

      document.getElementById("resultadoManual").innerText = 
        `Pr√≥ximo branco previsto para: ${previsaoHor} (baseado na m√©dia dos intervalos entre pedras).`;
    }

    // --- Inicializa√ß√£o ---
    atualizarNumEstrategias();
    atualizarEstatisticas();
    atualizarDesempenho();
  </script>
</body>
</html>
