<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Scofield Analista - Plano Sombra</title>
<style>
  body {
    background-color: #121212;
    color: #eee;
    font-family: 'Consolas', monospace, monospace;
    margin: 0; padding: 0;
    display: flex; flex-direction: column; min-height: 100vh;
  }
  header {
    background: #220000;
    padding: 1em;
    text-align: center;
    font-size: 1.5em;
    font-weight: bold;
    color: #f44336;
    user-select: none;
  }
  main {
    flex: 1;
    padding: 1em;
    max-width: 600px;
    margin: auto;
    display: flex;
    flex-direction: column;
    gap: 1em;
  }
  textarea {
    width: 100%;
    height: 120px;
    background: #222;
    border: none;
    border-radius: 4px;
    color: #eee;
    font-size: 1em;
    padding: 0.8em;
    resize: vertical;
  }
  label {
    font-weight: bold;
    color: #f44336;
  }
  button {
    background-color: #f44336;
    border: none;
    padding: 0.8em 1.2em;
    font-size: 1em;
    font-weight: bold;
    color: #fff;
    border-radius: 4px;
    cursor: pointer;
    user-select: none;
    transition: background-color 0.3s ease;
  }
  button:hover {
    background-color: #ff6659;
  }
  .btn-group {
    display: flex;
    gap: 0.8em;
    flex-wrap: wrap;
  }
  .output {
    background: #222;
    border-radius: 4px;
    padding: 1em;
    font-size: 1em;
    white-space: pre-wrap;
    min-height: 150px;
    color: #ddd;
  }
  .alert-strong {
    color: #ff3b3b;
    font-weight: bold;
  }
  .alert-weak {
    color: #ffa500;
    font-weight: bold;
  }
  .status {
    font-size: 0.9em;
    color: #aaa;
  }
</style>
</head>
<body>
<header>Scofield Analista - Plano Sombra</header>
<main>

<label for="historico">Cole aqui o hist√≥rico da Blaze (TipMiner):</label>
<textarea id="historico" placeholder="Exemplo:&#10;14:22:13 ‚Äî ‚ö´Ô∏è 5&#10;14:21:01 ‚Äî üî¥ 9&#10;14:20:32 ‚Äî ‚ö™Ô∏è 0"></textarea>

<div class="btn-group" style="flex-wrap: nowrap; gap:0.6em;">
  <button id="btn-analisar-historico">Analisar Hist√≥rico</button>
  <button id="btn-limpar-tudo" style="background:#555;">Limpar Tudo</button>
</div>

<hr style="border-color:#333; margin:1em 0;" />

<label>Informe o sinal manual:</label>

<div style="display:flex; flex-wrap: wrap; gap:1em;">

  <div style="flex:1 1 45%;">
    <label for="manual-anterior">Pedra Anterior (N√∫mero e Hor√°rio hh:mm:ss):</label>
    <input type="text" id="manual-anterior-num" placeholder="N√∫mero (ex: 5)" style="width:40%; padding:0.4em; font-size:1em;"/>
    <input type="text" id="manual-anterior-time" placeholder="Hor√°rio (ex: 14:22:13)" style="width:55%; padding:0.4em; font-size:1em;"/>
  </div>

  <div style="flex:1 1 45%;">
    <label for="manual-branco">Branco (Hor√°rio hh:mm:ss):</label>
    <input type="text" id="manual-branco-time" placeholder="Hor√°rio (ex: 14:20:32)" style="width:100%; padding:0.4em; font-size:1em;"/>
  </div>

  <div style="flex:1 1 45%;">
    <label for="manual-posterior">Pedra Posterior (N√∫mero e Hor√°rio hh:mm:ss):</label>
    <input type="text" id="manual-posterior-num" placeholder="N√∫mero (ex: 7)" style="width:40%; padding:0.4em; font-size:1em;"/>
    <input type="text" id="manual-posterior-time" placeholder="Hor√°rio (ex: 14:23:01)" style="width:55%; padding:0.4em; font-size:1em;"/>
  </div>

</div>

<div class="btn-group" style="margin-top:0.8em;">
  <button id="btn-analisar-sinal">Analisar Sinal Manual</button>
</div>

<hr style="border-color:#333; margin:1em 0;" />

<div class="output" id="output"></div>

<div style="margin-top:1em;">
  <button id="btn-acertou" style="background:#2ecc71;" disabled>Acertou</button>
  <button id="btn-errou" style="background:#e74c3c;" disabled>Errou</button>
</div>

<div class="status" id="status"></div>

<script>
(() => {
  const historicoEl = document.getElementById('historico');
  const outputEl = document.getElementById('output');
  const statusEl = document.getElementById('status');

  const btnAnalisarHistorico = document.getElementById('btn-analisar-historico');
  const btnLimparTudo = document.getElementById('btn-limpar-tudo');
  const btnAnalisarSinal = document.getElementById('btn-analisar-sinal');
  const btnAcertou = document.getElementById('btn-acertou');
  const btnErrou = document.getElementById('btn-errou');

  const manualAnteriorNum = document.getElementById('manual-anterior-num');
  const manualAnteriorTime = document.getElementById('manual-anterior-time');
  const manualBrancoTime = document.getElementById('manual-branco-time');
  const manualPosteriorNum = document.getElementById('manual-posterior-num');
  const manualPosteriorTime = document.getElementById('manual-posterior-time');

  // --- Dados salvos ---
  let historicoDados = []; // array de objetos { horario: Date, cor: string, numero: number|null }
  let estrategias = []; // array de estrat√©gias aprendidas
  let ultimoResultado = null; // resultado da √∫ltima an√°lise manual
  let pesosEstrategias = {}; // { idEstrategia: peso } - para ajustar por acertou/errou

  // --- Fun√ß√µes utilit√°rias ---

  // Parse de hor√°rio "HH:mm:ss" para Date do dia atual
  function parseHorario(horaStr) {
    const [h, m, s] = horaStr.split(':').map(x => parseInt(x,10));
    if (
      h>=0 && h<=23 &&
      m>=0 && m<=59 &&
      s>=0 && s<=59
    ) {
      const d = new Date();
      d.setHours(h, m, s, 0);
      return d;
    }
    return null;
  }

  // Formatar hor√°rio Date para "HH:mm:ss"
  function formatHorario(date) {
    return date.toTimeString().slice(0,8);
  }

  // Parsing linha do hist√≥rico
  // Exemplo linha: "14:22:13 ‚Äî ‚ö´Ô∏è 5" ou "14:20:32 ‚Äî ‚ö™Ô∏è"
  function parseLinhaHistorico(linha) {
    // Remove espa√ßos extras
    linha = linha.trim();
    if(!linha) return null;

    // Regex para hor√°rio, cor e opcional n√∫mero
    // Cor pode ser: ‚ö´Ô∏è (preto), üî¥ (vermelho), ‚ö™Ô∏è (branco)
    // O travess√£o √© '‚Äî' (U+2014)
    const regex = /^(\d{2}:\d{2}:\d{2})\s*‚Äî\s*(‚ö´Ô∏è|üî¥|‚ö™Ô∏è)(?:\s*(\d+))?$/u;
    const m = linha.match(regex);
    if(!m) return null;

    let cor = null;
    switch(m[2]){
      case '‚ö´Ô∏è': cor='preto'; break;
      case 'üî¥': cor='vermelho'; break;
      case '‚ö™Ô∏è': cor='branco'; break;
      default: cor=null;
    }
    const horario = parseHorario(m[1]);
    if(!horario) return null;

    const numero = m[3] !== undefined ? parseInt(m[3],10) : null;
    return { horario, cor, numero };
  }

  // Salvar estrat√©gias no localStorage
  function salvarEstrategias() {
    localStorage.setItem('scofield_estrategias', JSON.stringify(estrategias));
    localStorage.setItem('scofield_pesos', JSON.stringify(pesosEstrategias));
  }
  // Carregar estrat√©gias do localStorage
  function carregarEstrategias() {
    try {
      const est = JSON.parse(localStorage.getItem('scofield_estrategias'));
      if(Array.isArray(est)) estrategias = est;
      const pesos = JSON.parse(localStorage.getItem('scofield_pesos'));
      if(pesos && typeof pesos === 'object') pesosEstrategias = pesos;
    } catch {
      estrategias = [];
      pesosEstrategias = {};
    }
  }

  // Limpar tudo
  function limparTudo() {
    if(confirm("Deseja limpar todo hist√≥rico, estrat√©gias e pesos?")) {
      historicoDados = [];
      estrategias = [];
      pesosEstrategias = {};
      ultimoResultado = null;
      salvarEstrategias();
      historicoEl.value = '';
      manualAnteriorNum.value = '';
      manualAnteriorTime.value = '';
      manualBrancoTime.value = '';
      manualPosteriorNum.value = '';
      manualPosteriorTime.value = '';
      btnAcertou.disabled = true;
      btnErrou.disabled = true;
      outputEl.textContent = '';
      statusEl.textContent = 'Dados limpos.';
    }
  }

  // Criar ID para estrat√©gia
  function criarIdEstrategia(estrat) {
    // Exemplo: soma:17;intervaloSeg:200;cores:vermelho,preto,branco;
    return `soma:${estrat.soma};intervaloSeg:${estrat.intervaloSeg};cores:${estrat.cores.join(',')}`;
  }

  // Analisar hist√≥rico e gerar estrat√©gias
  function analisarHistorico() {
    outputEl.textContent = 'Analisando hist√≥rico...';
    const linhas = historicoEl.value.split('\n');
    const dados = [];
    for(let linha of linhas){
      const p = parseLinhaHistorico(linha);
      if(p) dados.push(p);
    }
    if(dados.length < 3) {
      outputEl.textContent = 'Erro: hist√≥rico inv√°lido ou incompleto (m√≠nimo 3 linhas).';
      return;
    }
    historicoDados = dados;

    // Detectar brancos e pedras anterior e posterior
    // Criar estrat√©gias baseadas em:
    // - Soma das pedras anterior + posterior
    // - Intervalo em segundos entre brancos
    // - Sequ√™ncia de cores anterior e posterior
    // - Hor√°rio de ocorr√™ncia

    const novasEstrategias = [];

    const brancos = historicoDados.filter(d=>d.cor==='branco');

    for(let i=0; i<brancos.length; i++){
      const branco = brancos[i];
      // achar √≠ndice do branco no hist√≥rico
      const idx = historicoDados.indexOf(branco);
      if(idx<=0 || idx>=historicoDados.length-1) continue;

      const anterior = historicoDados[idx-1];
      const posterior = historicoDados[idx+1];
      if(!anterior || !posterior) continue;

      // soma dos n√∫meros das pedras anterior + posterior
      if(anterior.numero === null || posterior.numero === null) continue;
      const soma = anterior.numero + posterior.numero;

      // intervalo em segundos para pr√≥ximo branco (se existir)
      let intervaloSeg = null;
      if(i < brancos.length -1) {
        intervaloSeg = (brancos[i+1].horario - branco.horario)/1000;
      }

      // sequ√™ncia de cores (anterior, branco, posterior)
      const cores = [anterior.cor, branco.cor, posterior.cor];

      // hor√°rio do branco em minutos e segundos
      const minuto = branco.horario.getMinutes();
      const segundo = branco.horario.getSeconds();

      // criar estrat√©gia
      const estrategia = {
        id: criarIdEstrategia({ soma, intervaloSeg: intervaloSeg||0, cores }),
        soma,
        intervaloSeg: intervaloSeg||0,
        cores,
        minuto,
        segundo,
        peso: pesosEstrategias[ criarIdEstrategia({ soma, intervaloSeg: intervaloSeg||0, cores }) ] || 1
      };

      // evitar duplicatas
      if(!estrategias.find(e=>e.id === estrategia.id)){
        novasEstrategias.push(estrategia);
      }
    }

    // juntar com as estrat√©gias j√° existentes e salvar
    estrategias = estrategias.concat(novasEstrategias);
    salvarEstrategias();

    outputEl.textContent = `An√°lise conclu√≠da.\nEstrat√©gias aprendidas: ${estrategias.length}`;
    statusEl.textContent = 'Hist√≥rico analisado e estrat√©gias atualizadas.';
    btnAcertou.disabled = true;
    btnErrou.disabled = true;
  }

  // Fun√ß√£o para verificar se um sinal manual bate com alguma estrat√©gia salva
  function analisarSinalManual() {
    outputEl.textContent = 'Analisando sinal manual...';

    // Ler dados manuais
    const antNum = parseInt(manualAnteriorNum.value, 10);
    const antTime = parseHorario(manualAnteriorTime.value);
    const brancoTime = parseHorario(manualBrancoTime.value);
    const postNum = parseInt(manualPosteriorNum.value, 10);
    const postTime = parseHorario(manualPosteriorTime.value);

    if(
      isNaN(antNum) || !antTime ||
      !brancoTime ||
      isNaN(postNum) || !postTime
    ) {
      outputEl.textContent = 'Erro: Preencha corretamente os n√∫meros e hor√°rios com segundos.';
      return;
    }

    // Criar dados de sinal manual
    const sinal = {
      anterior: { numero: antNum, horario: antTime, cor: null },
      branco: { horario: brancoTime },
      posterior: { numero: postNum, horario: postTime, cor: null }
    };

    // Verificar estrat√©gias que batem com esse sinal
    // Crit√©rios simples: soma igual, cores igual (considerando pedra branca no meio), intervalo aproximado

    const somaSinal = antNum + postNum;
    const minutoSinal = brancoTime.getMinutes();
    const segundoSinal = brancoTime.getSeconds();

    let encontrados = [];

    for(let est of estrategias){
      // soma igual
      if(est.soma !== somaSinal) continue;

      // intervalo entre brancos: toler√¢ncia de +/- 10 segundos
      const intervaloDiff = Math.abs(est.intervaloSeg - ((brancoTime - antTime)/1000));
      if(intervaloDiff > 15) continue;

      // cor sequ√™ncia
      if(est.cores[0] !== 'preto' && est.cores[0] !== 'vermelho') continue; // simplifica√ß√£o para demo
      if(est.cores[1] !== 'branco') continue;
      if(est.cores[2] !== 'preto' && est.cores[2] !== 'vermelho') continue;

      encontrados.push(est);
    }

    if(encontrados.length === 0){
      outputEl.textContent = 'Nenhuma estrat√©gia conhecida identificada neste momento.';
      btnAcertou.disabled = true;
      btnErrou.disabled = true;
      ultimoResultado = null;
      statusEl.textContent = '';
      return;
    }

    // Classificar pelo peso (mais forte primeiro)
    encontrados.sort((a,b)=> (pesosEstrategias[b.id]||1) - (pesosEstrategias[a.id]||1));

    ultimoResultado = encontrados[0];

    // Mostrar resultado
    outputEl.innerHTML = `
      <span class="${ultimoResultado.peso >=2 ? 'alert-strong' : 'alert-weak'}">Padr√£o reconhecido ‚Äî alerta de branco prov√°vel!</span>
      \nEstrat√©gia: Soma ${ultimoResultado.soma}, Intervalo ~${Math.round(ultimoResultado.intervaloSeg)}s
      \nPr√≥ximo branco prov√°vel por volta de <b>${formatHorario(new Date(brancoTime.getTime() + ultimoResultado.intervaloSeg*1000))}</b>
      \nPeso da estrat√©gia: ${ultimoResultado.peso.toFixed(2)}
      \n‚ÄúSe voc√™ estiver lendo isso... o plano j√° come√ßou.‚Äù
    `;

    // Habilitar bot√µes para aprendizado
    btnAcertou.disabled = false;
    btnErrou.disabled = false;

    // Status com indica√ß√£o forte ou fraco
    statusEl.textContent = ultimoResultado.peso >= 2
      ? 'Sinal FORTE - prepare-se!'
      : 'Sinal FRACO - aposte com cautela.';
  }

  // Ajustar peso da estrat√©gia com base em feedback
  function feedbackAcertou() {
    if(!ultimoResultado) return;
    pesosEstrategias[ultimoResultado.id] = (pesosEstrategias[ultimoResultado.id] || 1) + 1;
    salvarEstrategias();
    statusEl.textContent = 'Feedback: Acertou! Peso da estrat√©gia aumentado.';
    btnAcertou.disabled = true;
    btnErrou.disabled = true;
  }
  function feedbackErrou() {
    if(!ultimoResultado) return;
    pesosEstrategias[ultimoResultado.id] = Math.max(0, (pesosEstrategias[ultimoResultado.id] || 1) - 1);
    salvarEstrategias();
    statusEl.textContent = 'Feedback: Errou. Peso da estrat√©gia reduzido.';
    btnAcertou.disabled = true;
    btnErrou.disabled = true;
  }

  // Detec√ß√£o simples de REC e chuva de brancos (baseado em intervalo)
  function detectarRecOuChuva() {
    if(historicoDados.length === 0) return '';

    const brancos = historicoDados.filter(d => d.cor === 'branco').sort((a,b)=>a.horario-b.horario);
    if(brancos.length < 2) return '';

    const ultimoBranco = brancos[brancos.length -1];
    const penultimoBranco = brancos[brancos.length -2];
    const intervaloSeg = (ultimoBranco.horario - penultimoBranco.horario)/1000;

    if(intervaloSeg <= 90) return 'üåßÔ∏è Chuva de brancos detectada!';

    if(intervaloSeg >= 180 && intervaloSeg <= 300) return 'üîÑ REC detectada!';

    return '';
  }

  // Inicializar
  function init() {
    carregarEstrategias();
    btnAnalisarHistorico.onclick = analisarHistorico;
    btnLimparTudo.onclick = limparTudo;
    btnAnalisarSinal.onclick = analisarSinalManual;
    btnAcertou.onclick = feedbackAcertou;
    btnErrou.onclick = feedbackErrou;

    outputEl.textContent = 'Cole o hist√≥rico e clique em "Analisar Hist√≥rico" para come√ßar.';
    statusEl.textContent = '';
  }

  init();

})();
</script>

</main>
</body>
</html>
