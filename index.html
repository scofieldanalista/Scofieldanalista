<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Scofield Analista - Previs√£o Branco</title>
  <style>
    body { font-family: Arial, sans-serif; background: #fff; color: #000; padding: 20px; }
    button { margin: 5px; padding: 12px 20px; font-size: 16px; cursor: pointer; border: none; border-radius: 5px; }
    .vermelho { background: #c0392b; color: white; }
    .preto { background: #000; color: white; }
    .branco { background: #ecf0f1; color: #000; border: 1px solid #ccc; }
    #log { margin-top: 20px; max-height: 200px; overflow-y: auto; background: #eee; padding: 10px; }
    #prediction { margin-top: 20px; }
  </style>
</head>
<body>

<h1>Scofield Analista - Previs√£o Branco (5 min antes)</h1>

<div>
  <button class="vermelho" onclick="addCor('vermelho')">üî¥ Vermelho</button>
  <button class="preto" onclick="addCor('preto')">‚ö´ Preto</button>
  <button class="branco" onclick="addCor('branco')">‚ö™ Branco</button>
</div>

<div id="log"></div>
<div id="prediction"></div>

<script>
  const logDiv = document.getElementById('log');
  const predictionDiv = document.getElementById('prediction');
  let results = JSON.parse(localStorage.getItem('results')) || [];

  let parcial = []; // Guarda as duas cores do mesmo minuto
  let minutoAtual = results.length ? results[results.length - 1].minuto + 1 : 0;

  function addCor(cor) {
    parcial.push(cor);

    if (parcial.length === 2) {
      // Salva as duas cores como um registro do mesmo minuto
      results.push({
        minuto: minutoAtual,
        cores: [...parcial]
      });
      parcial = [];
      minutoAtual++;
      localStorage.setItem('results', JSON.stringify(results));
      updateLog();
      predictNextWhite();
    }
  }

  function updateLog() {
    logDiv.innerHTML = '';
    results.forEach(r => {
      const coresStr = r.cores.map(c => {
        if (c === 'vermelho') return 'üî¥';
        if (c === 'preto') return '‚ö´';
        if (c === 'branco') return '‚ö™';
      }).join(' ');
      logDiv.innerHTML += `<div>Minuto ${r.minuto}: ${coresStr}</div>`;
    });
  }

  function predictNextWhite() {
    const brancos = results.filter(r => r.cores.includes('branco'));

    if (brancos.length < 2) {
      predictionDiv.innerHTML = '‚ö†Ô∏è Dados insuficientes para prever o branco.';
      return null;
    }

    // Calcula a m√©dia de minutos entre brancos
    let intervalos = [];
    for (let i = 1; i < brancos.length; i++) {
      intervalos.push(brancos[i].minuto - brancos[i - 1].minuto);
    }
    const media = intervalos.reduce((a, b) => a + b, 0) / intervalos.length;

    const ultimoBranco = brancos[brancos.length - 1].minuto;
    const previsto = Math.round(ultimoBranco + media);
    const agora = minutoAtual;

    const falta = previsto - agora;

    predictionDiv.innerHTML = `
      <p>üß† M√©dia entre brancos: ${media.toFixed(1)} minutos</p>
      <p>üìÖ Pr√≥ximo branco previsto: <strong>Minuto ${previsto}</strong></p>
      <p>‚è∞ Faltam: <strong>${falta}</strong> minuto(s)</p>
    `;

    return { previsto, falta };
  }

  function startAlertCountdown() {
    const alertaMinutosAntes = 5;

    function checar() {
      const pred = predictNextWhite();
      if (!pred) return;

      if (pred.falta <= alertaMinutosAntes && pred.falta > 0) {
        alert(`‚ö†Ô∏è ALERTA: Branco previsto em ${pred.falta} minutos!`);
        playAlertSound();
        clearInterval(intervalo);
      }
    }

    const intervalo = setInterval(checar, 5000);
  }

  function playAlertSound() {
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const oscillator = audioCtx.createOscillator();
    oscillator.type = 'square';
    oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
    oscillator.connect(audioCtx.destination);
    oscillator.start();
    oscillator.stop(audioCtx.currentTime + 0.5);
  }

  // In√≠cio
  updateLog();
  predictNextWhite();
  startAlertCountdown();
</script>

</body>
</html>
