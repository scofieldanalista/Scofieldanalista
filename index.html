<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Scofield Analista - Previsão Branco Blaze</title>
<style>
  body {
    font-family: Arial, sans-serif;
    background: #121212;
    color: #eee;
    margin: 0; padding: 20px;
  }
  h1 {
    color: #f44336;
    text-align: center;
  }
  textarea, input {
    width: 100%;
    padding: 10px;
    margin-top: 10px;
    font-size: 1em;
    border-radius: 5px;
    border: none;
    outline: none;
  }
  button {
    background: #f44336;
    color: white;
    border: none;
    padding: 12px 20px;
    margin-top: 10px;
    font-size: 1em;
    cursor: pointer;
    border-radius: 5px;
    width: 100%;
  }
  button:hover {
    background: #d32f2f;
  }
  .history-block {
    max-height: 200px;
    overflow-y: auto;
    margin-top: 10px;
    background: #222;
    padding: 10px;
    border-radius: 5px;
    font-size: 0.9em;
  }
  .entry {
    padding: 4px 6px;
    margin-bottom: 2px;
    border-radius: 3px;
  }
  .red {
    background-color: #b71c1c;
  }
  .black {
    background-color: #212121;
  }
  .white {
    background-color: #eee;
    color: #111;
    font-weight: bold;
  }
  .input-row {
    display: flex;
    gap: 10px;
    margin-top: 15px;
  }
  .input-group {
    flex: 1;
  }
  label {
    font-weight: bold;
    display: block;
    margin-bottom: 5px;
  }
  .prediction {
    margin-top: 15px;
    font-size: 1.2em;
    font-weight: bold;
    color: #fff;
    text-align: center;
  }
  .alert {
    color: #f44336;
    font-weight: bold;
    animation: blink 1s infinite;
  }
  @keyframes blink {
    0%, 100% {opacity:1;}
    50% {opacity:0.3;}
  }
  .buttons-row {
    display: flex;
    gap: 10px;
    margin-top: 10px;
  }
  .buttons-row button {
    flex: 1;
  }
</style>
</head>
<body>

<h1>Scofield Analista - Previsão Branco Blaze</h1>

<label for="historyInput">Cole o histórico completo (data, número, horário):</label>
<textarea id="historyInput" rows="10" placeholder="Cole aqui o histórico conforme exemplo..."></textarea>
<button id="loadHistoryBtn">Carregar Histórico e Analisar</button>

<div class="history-block" id="historyDisplay"></div>

<hr />

<h2>Inserção Manual de Pedras</h2>
<div class="input-row">
  <div class="input-group">
    <label for="prevNumber">Pedra Anterior (Número):</label>
    <input type="number" id="prevNumber" min="1" max="14" placeholder="Número 1-14" />
  </div>
  <div class="input-group">
    <label for="prevTime">Horário Pedra Anterior (HH:MM:SS):</label>
    <input type="time" id="prevTime" step="1" placeholder="HH:MM:SS" />
  </div>
</div>
<div class="input-row">
  <div class="input-group">
    <label for="whiteTime">Horário Branco (HH:MM:SS):</label>
    <input type="time" id="whiteTime" step="1" placeholder="HH:MM:SS" />
  </div>
  <div class="input-group">
    <label for="nextNumber">Pedra Posterior (Número):</label>
    <input type="number" id="nextNumber" min="1" max="14" placeholder="Número 1-14" />
  </div>
  <div class="input-group">
    <label for="nextTime">Horário Pedra Posterior (HH:MM:SS):</label>
    <input type="time" id="nextTime" step="1" placeholder="HH:MM:SS" />
  </div>
</div>

<button id="analyzeManualBtn">Analisar Manualmente</button>

<div class="prediction" id="predictionText"></div>

<div class="buttons-row">
  <button id="btnHit">Acertou</button>
  <button id="btnMiss">Errou</button>
</div>

<script>
// Configuração: quais números são vermelhos e pretos
const RED_NUMS = new Set([1,2,3,4,5,6,7]);
const BLACK_NUMS = new Set([8,9,11,12,13,14]);

// Armazenamento local
const STORAGE_HISTORY_KEY = 'scofield_history';
const STORAGE_STRATEGIES_KEY = 'scofield_strategies';
const STORAGE_LEARNING_KEY = 'scofield_learning';

// Estado do app
let historyData = [];
let strategies = [];
let learning = {
  hits: 0,
  misses: 0
};

const historyInput = document.getElementById('historyInput');
const loadHistoryBtn = document.getElementById('loadHistoryBtn');
const historyDisplay = document.getElementById('historyDisplay');

const prevNumberInput = document.getElementById('prevNumber');
const prevTimeInput = document.getElementById('prevTime');
const whiteTimeInput = document.getElementById('whiteTime');
const nextNumberInput = document.getElementById('nextNumber');
const nextTimeInput = document.getElementById('nextTime');

const analyzeManualBtn = document.getElementById('analyzeManualBtn');
const predictionText = document.getElementById('predictionText');

const btnHit = document.getElementById('btnHit');
const btnMiss = document.getElementById('btnMiss');

function saveToStorage() {
  localStorage.setItem(STORAGE_HISTORY_KEY, JSON.stringify(historyData));
  localStorage.setItem(STORAGE_STRATEGIES_KEY, JSON.stringify(strategies));
  localStorage.setItem(STORAGE_LEARNING_KEY, JSON.stringify(learning));
}
function loadFromStorage() {
  const h = localStorage.getItem(STORAGE_HISTORY_KEY);
  const s = localStorage.getItem(STORAGE_STRATEGIES_KEY);
  const l = localStorage.getItem(STORAGE_LEARNING_KEY);
  if(h) historyData = JSON.parse(h);
  if(s) strategies = JSON.parse(s);
  if(l) learning = JSON.parse(l);
}
loadFromStorage();

function parseHistory(text) {
  // O formato esperado é:
  // Linha 1: data e hora completa ou só data (ex: 15/07/2025 19:14:55)
  // Linha 2: número da pedra (1-14) OU vazio para branco
  // Linha 3: horário (HH:MM:SS)
  // Repetir...

  const lines = text.trim().split('\n').map(l => l.trim()).filter(l => l.length > 0);
  let parsed = [];
  for(let i=0; i < lines.length; i+=3){
    if(i+2 >= lines.length) break;
    const fullDate = lines[i];
    const numLine = lines[i+1];
    const timeLine = lines[i+2];
    let number = null;
    if(numLine !== '') number = Number(numLine);
    // Identificar cor
    let color = null;
    if(number === null) {
      color = 'white';
    } else if(RED_NUMS.has(number)) {
      color = 'red';
    } else if(BLACK_NUMS.has(number)) {
      color = 'black';
    } else {
      color = 'unknown';
    }
    parsed.push({
      fullDate,
      number,
      time: timeLine,
      color
    });
  }
  return parsed;
}

function displayHistory() {
  if(historyData.length === 0){
    historyDisplay.innerHTML = 'Nenhum histórico carregado.';
    return;
  }
  let html = '';
  historyData.forEach(entry => {
    let classColor = entry.color === 'red' ? 'red' : (entry.color === 'black' ? 'black' : 'white');
    html += `<div class="entry ${classColor}">${entry.time} - Pedra: ${entry.number !== null ? entry.number : 'BRANCO'}</div>`;
  });
  historyDisplay.innerHTML = html;
}

function analyzeHistory() {
  // Aqui você pode implementar suas estratégias para detectar padrões e brancos futuros.
  // Exemplo simples: procurar sequências onde o branco apareceu após certas combinações.
  // Para simplificar, vamos só mostrar quantos brancos existem no histórico.

  const brancos = historyData.filter(e => e.color === 'white');
  return brancos.length;
}

function addStrategy(strategy) {
  strategies.push(strategy);
  saveToStorage();
}

function analyzeManualInput() {
  const prevNum = Number(prevNumberInput.value);
  const prevTime = prevTimeInput.value;
  const whiteTime = whiteTimeInput.value;
  const nextNum = Number(nextNumberInput.value);
  const nextTime = nextTimeInput.value;

  if(!prevNum || !prevTime || !whiteTime || !nextNum || !nextTime){
    alert('Por favor, preencha todos os campos de inserção manual.');
    return;
  }
  if(prevNum < 1 || prevNum > 14 || nextNum < 1 || nextNum > 14){
    alert('Números de pedra devem estar entre 1 e 14.');
    return;
  }

  // Criar objeto manual de análise
  const manualEntry = {
    prevNum, prevTime, whiteTime, nextNum, nextTime
  };

  // Aqui a lógica para verificar se esse padrão já existe nas estratégias
  // ou salvar como nova estratégia de aprendizado
  // Para simplificar, vamos salvar a estratégia baseada nessa entrada manual:

  addStrategy(manualEntry);

  predictionText.textContent = 'Estratégia manual salva! Agora aguarde novas previsões.';

  saveToStorage();
}

function predictNextWhite() {
  // Exemplo básico de previsão baseado nas estratégias armazenadas e histórico
  if(strategies.length === 0) {
    predictionText.textContent = 'Nenhuma estratégia salva para previsão.';
    return;
  }
  // Para demonstrar, vamos pegar a última estratégia e sugerir o próximo branco no horário + 1 min
  const lastStrategy = strategies[strategies.length -1];
  // Parse tempo para minutos e segundos
  const parts = lastStrategy.whiteTime.split(':');
  if(parts.length < 3) {
    predictionText.textContent = 'Formato horário inválido na última estratégia.';
    return;
  }
  let h = parseInt(parts[0],10);
  let m = parseInt(parts[1],10);
  let s = parseInt(parts[2],10);

  s += 30; // Previs
