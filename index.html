<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scofield Analista PRO ‚ö™</title>
  <style>
    body {
      background: #111;
      color: #eee;
      font-family: 'Segoe UI', sans-serif;
      padding: 15px;
    }
    h1 {
      text-align: center;
      color: #ff4747;
    }
    textarea,
    input,
    button {
      width: 100%;
      padding: 10px;
      margin: 5px 0;
      border-radius: 5px;
      box-sizing: border-box;
    }
    textarea,
    input {
      background: #222;
      color: #eee;
      border: 1px solid #555;
      font-size: 1em;
      font-family: monospace;
    }
    button {
      background: #ff4747;
      color: white;
      border: none;
      cursor: pointer;
      font-weight: bold;
      font-size: 1em;
    }
    button:hover {
      background: #e53e3e;
    }
    .secao {
      margin-top: 25px;
    }
    .sinal {
      background: #222;
      padding: 10px;
      margin-top: 10px;
      border-radius: 5px;
    }
    .sinal button {
      width: 48%;
      margin: 2px 1%;
      font-weight: bold;
    }
    .estatisticas {
      white-space: pre-line;
      background: #222;
      padding: 10px;
      border-radius: 5px;
      margin-top: 15px;
      font-size: 1em;
      max-height: 150px;
      overflow-y: auto;
      font-family: monospace;
    }
    #contadorEstrategias {
      margin-top: 10px;
      font-size: 1.1em;
      color: #ff6666;
      font-weight: bold;
      text-align: center;
    }
    #mensagemCerebro,
    #mensagemHistorico,
    #mensagemAlerta {
      margin-top: 10px;
      font-weight: bold;
      text-align: center;
    }
    #mensagemCerebro {
      color: #8f8;
    }
    #mensagemHistorico {
      color: #8f8;
    }
    #mensagemAlerta {
      color: #ff4747;
    }
  </style>
</head>
<body>
  <h1>Scofield Analista PRO ‚ö™</h1>

  <div class="secao">
    <h3>üß† Hist√≥rico C√©rebro</h3>
    <textarea
      id="historicoCerebro"
      rows="10"
      placeholder="Cole aqui o hist√≥rico completo com hor√°rios, n√∫meros e cores... Exemplo: 
1
23:45:03
2
12
23:44:33
3
1
23:44:03
..."
    ></textarea>
    <button onclick="enviarCerebro()">üì§ Enviar Hist√≥rico</button>
    <div id="mensagemCerebro"></div>
    <div id="contadorEstrategias">üìö Estrat√©gias criadas: 0</div>
  </div>

  <div class="secao">
    <h3>‚è±Ô∏è Hist√≥rico Atual para An√°lise</h3>
    <textarea
      id="historicoAtual"
      rows="8"
      placeholder="Cole aqui as √∫ltimas jogadas para prever os brancos..."
    ></textarea>
    <button onclick="analisarAgora()">üîç Analisar</button>
    <div id="mensagemAlerta"></div>
    <div id="previsoes"></div>
  </div>

  <div class="secao">
    <h3>üìä Estat√≠sticas de Acertos e Erros</h3>
    <div id="estatisticas" class="estatisticas"></div>
    <button onclick="limparEstatisticas()">üßπ Limpar Estat√≠sticas</button>
  </div>

  <div class="secao">
    <h3>üßπ Limpar Hist√≥rico</h3>
    <button onclick="limparHistorico()">üßº Limpar Campos de Hist√≥rico</button>
    <div id="mensagemHistorico"></div>
  </div>

  <script>
    // Dados salvos localmente
    let estrategias = JSON.parse(localStorage.getItem("estrategias") || "[]");
    let estatisticas = JSON.parse(localStorage.getItem("estatisticas") || "[]");
    let historicosAprendidos = JSON.parse(localStorage.getItem("historicosAprendidos") || "[]");

    // Atualiza contador de estrat√©gias vis√≠vel
    function atualizarContadorEstrategias() {
      document.getElementById("contadorEstrategias").innerText =
        `üìö Estrat√©gias criadas: ${estrategias.length}`;
    }

    // Salva dados no localStorage
    function salvarDados() {
      localStorage.setItem("estrategias", JSON.stringify(estrategias));
      localStorage.setItem("estatisticas", JSON.stringify(estatisticas));
      localStorage.setItem("historicosAprendidos", JSON.stringify(historicosAprendidos));
      atualizarEstatisticas();
      atualizarContadorEstrategias();
    }

    // Parseia o hist√≥rico c√©rebro e cria estrat√©gias (somando pedras anterior + posterior)
    function enviarCerebro() {
      const texto = document.getElementById("historicoCerebro").value.trim();
      if (texto.length < 10) return alert("Hist√≥rico muito curto.");

      const linhas = texto.split("\n").map(l => l.trim()).filter(l => l !== "");
      if (linhas.length < 3) {
        alert("Hist√≥rico incompleto, faltam dados.");
        return;
      }

      // Extrai trios: anterior, hor√°rio, posterior (no formato esperado)
      // Exemplo esperado: n√∫mero / hor√°rio / n√∫mero
      // Ajuste conforme seu hist√≥rico, aqui assumo padr√£o: n√∫mero, hor√°rio, n√∫mero
      // Por seguran√ßa, vamos iterar 3 em 3 e validar
      let novasEstrategiasCriadas = 0;
      let novoHistorico = [];

      for (let i = 0; i <= linhas.length - 3; i += 3) {
        const anterior = parseInt(linhas[i]);
        const horario = linhas[i + 1];
        const posterior = parseInt(linhas[i + 2]);

        if (
          isNaN(anterior) ||
          isNaN(posterior) ||
          !horario.match(/^\d{2}:\d{2}:\d{2}$/)
        ) {
          // Pula linhas inv√°lidas
          continue;
        }

        const soma = anterior + posterior;

        // Adiciona nova estrat√©gia se ainda n√£o existe
        if (!estrategias.some(e => e.tipo === "soma" && e.soma === soma)) {
          estrategias.push({
            tipo: "soma",
            soma: soma,
            peso: 1,
            horarios: [horario],
          });
          novasEstrategiasCriadas++;
        } else {
          // Se existe, adiciona o hor√°rio para ajudar a detectar padr√£o hor√°rio
          const e = estrategias.find(e => e.tipo === "soma" && e.soma === soma);
          if (!e.horarios.includes(horario)) {
            e.horarios.push(horario);
          }
        }

        // Monta o hist√≥rico aprendido para padr√µes REC e CHUVA (sequ√™ncia de hor√°rios brancos)
        novoHistorico.push({ anterior, horario, posterior, soma });
      }

      // Salva hist√≥rico aprendido para compara√ß√£o futura
      if (novoHistorico.length > 0) {
        historicosAprendidos.push(novoHistorico);
      }

      document.getElementById("mensagemCerebro").innerText =
        novasEstrategiasCriadas > 0
          ? `‚úÖ Hist√≥rico analisado com sucesso! ${novasEstrategiasCriadas} novas estrat√©gias criadas.`
          : "‚úÖ Hist√≥rico analisado. Nenhuma nova estrat√©gia identificada.";

      salvarDados();
    }

    // Fun√ß√£o para calcular n√≠vel do sinal baseado no peso da estrat√©gia
    function calcularNivel(peso) {
      return peso >= 3 ? "Forte" : peso === 2 ? "Moderado" : "Arriscado";
    }

    // Fun√ß√£o para analisar o hist√≥rico atual e prever hor√°rios reais dos brancos
    function analisarAgora() {
      const texto = document.getElementById("historicoAtual").value.trim();
      const linhas = texto.split("\n").map(l => l.trim()).filter(l => l !== "");

      if (linhas.length < 3) {
        alert("Hist√≥rico atual muito curto para an√°lise.");
        return;
      }

      // Monta lista de previs√µes encontradas
      let horariosPrevistos = [];
      let mensagensAlertas = [];

      // Mapeia estrat√©gias que coincidem com o hist√≥rico atual
      estrategias.forEach(estrategia => {
        if (estrategia.tipo === "soma") {
          for (let i = 0; i <= linhas.length - 3; i += 3) {
            const anterior = parseInt(linhas[i]);
            const horario = linhas[i + 1];
            const posterior = parseInt(linhas[i + 2]);
            const soma = anterior + posterior;
            if (soma === estrategia.soma) {
              horariosPrevistos.push({
                horario,
                nivel: calcularNivel(estrategia.peso),
                estrategia,
              });
            }
          }
        }
      });

      // Remove duplicados por hor√°rio
      horariosPrevistos = horariosPrevistos.filter(
        (item, pos, self) =>
          self.findIndex((t) => t.horario === item.horario) === pos
      );

      // Detecta padr√µes REC e CHUVA comparando o hist√≥rico atual com os hist√≥ricos aprendidos
      const padraoDetectado = detectarPadraoRECouCHUVA(linhas);

      if (padraoDetectado) {
        mensagensAlertas.push(
          padraoDetectado === "REC"
            ? "‚ö†Ô∏è Padr√£o REC detectado ‚Äî poucos brancos em sequ√™ncia."
            : "‚ö™ Padr√£o CHUVA detectado ‚Äî v√°rios brancos pr√≥ximos."
        );
      }

      // Exibe alertas
      const mensagemAlertaDiv = document.getElementById("mensagemAlerta");
      mensagemAlertaDiv.innerText = mensagensAlertas.join(" ");

      // Exibe previs√µes ou mensagem de aus√™ncia
      const div = document.getElementById("previsoes");
      if (horariosPrevistos.length) {
        div.innerHTML = "<h4>üü¢ Brancos Prov√°veis:</h4>";
        horariosPrevistos.forEach((p) => {
          const sinalDiv = document.createElement("div");
          sinalDiv.className = "sinal";
          sinalDiv.innerHTML = `
            <strong>${p.horario}</strong> (${p.nivel})<br>
            Estrat√©gia: Soma = ${p.estrategia.soma}<br>
            <button onclick="registrarResultado('${p.horario}', 'win', ${p.estrategia.soma})">‚úÖ Acertou</button>
            <button onclick="registrarResultado('${p.horario}', 'loss', ${p.estrategia.soma})">‚ùå Errou</button>
          `;
          div.appendChild(sinalDiv);
        });
      } else {
        div.innerHTML = "<p>üîç Nenhum padr√£o detectado. Tente enviar um hist√≥rico mais completo.</p>";
      }
    }

    // Registrar resultado e ajustar peso da estrat√©gia
    function registrarResultado(horario, resultado, soma) {
      estatisticas.push({ horario, resultado: resultado === "win" ? "‚úÖ" : "‚ùå" });
      // Ajustar peso da estrat√©gia relacionada
      let estrategia = estrategias.find((e) => e.tipo === "soma" && e.soma === soma);
      if (estrategia) {
        if (resultado === "win") {
          estrategia.peso = Math.min(estrategia.peso + 1, 5);
        } else {
          estrategia.peso = Math.max(estrategia.peso - 1, 1);
        }
      }
      salvarDados();
    }

    // Atualizar e exibir estat√≠sticas
    function atualizarEstatisticas() {
      const div = document.getElementById("estatisticas");
      if (estatisticas.length === 0) {
        div.innerText = "Nenhuma estat√≠stica ainda.";
        return;
      }
      div.innerText = estatisticas
        .map((e, i) => `${i + 1}. ${e.horario} ${e.resultado}`)
        .reverse()
        .join("\n");
    }

    // Limpar estat√≠sticas
    function limparEstatisticas() {
      if (confirm("Tem certeza que deseja apagar as estat√≠sticas?")) {
        estatisticas = [];
        salvarDados();
      }
    }

    // Limpar hist√≥ricos dos campos (mas manter estrat√©gias e estat√≠sticas)
    function limparHistorico() {
      document.getElementById("historicoCerebro").value = "";
      document.getElementById("historicoAtual").value = "";
      document.getElementById("mensagemCerebro").innerText = "";
      document.getElementById("mensagemHistorico").innerText = "‚úÖ Campos de hist√≥rico limpos! Estrat√©gias mantidas.";
      document.getElementById("previsoes").innerHTML = "";
      document.getElementById("mensagemAlerta").innerText = "";
    }

    // Fun√ß√£o para detectar padr√µes REC e CHUVA
    // Recebe linhas do hist√≥rico atual no formato: [anterior, horario, posterior, anterior, horario, posterior, ...]
    function detectarPadraoRECouCHUVA(linhas) {
      // Primeiro, transformamos linhas em array de hor√°rios dos brancos
      // Buscamos sequ√™ncias onde houve poucos ou muitos brancos em intervalo curto ou longo
      // A l√≥gica pode ser melhorada, mas vamos usar uma abordagem simples:

      // Obter array s√≥ com hor√°rios (assumindo posi√ß√£o √≠mpar do hist√≥rico)
      let horarios = [];
      for (let i = 1; i < linhas.length; i += 3) {
        if (linhas[i].match(/^\d{2}:\d{2}:\d{2}$/)) {
          horarios.push(linhas[i]);
        }
      }
      if (horarios.length < 2) return false;

      // Convertendo hor√°rios para segundos do dia
      const toSegundos = (h) => {
        const [hh, mm, ss] = h.split(":").map(Number);
        return hh * 3600 + mm * 60 + ss;
      };
      const segundos = horarios.map(toSegundos);

      // Calcular diferen√ßas entre hor√°rios consecutivos
      let diffs = [];
      for (let i = 1; i < segundos.length; i++) {
        diffs.push(segundos[i] - segundos[i - 1]);
      }

      // Definir thresholds arbitr√°rios para REC e CHUVA (pode ser ajustado)
      const thresholdRec = 600; // 10 minutos sem branco = REC
      const thresholdChuva = 120; // menos de 2 minutos entre brancos = CHUVA

      // Contar quantas vezes houve intervalo maior que thresholdRec
      const recs = diffs.filter(d => d >= thresholdRec).length;
      // Contar quantas vezes intervalo menor que thresholdChuva
      const chuvas = diffs.filter(d => d <= thresholdChuva).length;

      // Verificar se os padr√µes se repetem em hist√≥ricos aprendidos no mesmo hor√°rio
      // Vamos verificar similaridade com hist√≥ricos anteriores
      const similaridadeREC = historicosAprendidos.some(historico => {
        // Historico √© array [{anterior, horario, posterior, soma}, ...]
        // Extrair hor√°rios e converter para segundos
        const horariosHist = historico.map(h => h.horario).filter(h => /^\d{2}:\d{2}:\d{2}$/.test(h));
        if (horariosHist.length < 2) return false;
        const segundosHist = horariosHist.map(toSegundos);

        // Calcular diffs
        let diffsHist = [];
        for (let i = 1; i < segundosHist.length; i++) {
          diffsHist.push(segundosHist[i] - segundosHist[i - 1]);
        }

        // Comparar se ambos t√™m n√∫mero semelhante de intervalos longos (REC)
        const recsHist = diffsHist.filter(d => d >= thresholdRec).length;
        return Math.abs(recsHist - recs) <= 1; // diferen√ßa pequena
      });

      const similaridadeCHUVA = historicosAprendidos.some(historico => {
        const horariosHist = historico.map(h => h.horario).filter(h => /^\d{2}:\d{2}:\d{2}$/.test(h));
        if (horariosHist.length < 2) return false;
        const segundosHist = horariosHist.map(toSegundos);
        let diffsHist = [];
        for (let i = 1; i < segundosHist.length; i++) {
          diffsHist.push(segundosHist[i] - segundosHist[i - 1]);
        }
        const chuvasHist = diffsHist.filter(d => d <= thresholdChuva).length;
        return Math.abs(chuvasHist - chuvas) <= 1;
      });

      if (recs >= 2 && similaridadeREC) return "REC";
      if (chuvas >= 2 && similaridadeCHUVA) return "CHUVA";
      return false;
    }

    // Inicializa visualiza√ß√µes ao carregar
    atualizarEstatisticas();
    atualizarContadorEstrategias();
  </script>
</body>
</html>
