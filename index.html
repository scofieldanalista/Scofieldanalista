<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Scofield Analista — Plano Sombra</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');
  body {
    background-color: #121212;
    color: #eee;
    font-family: 'Share Tech Mono', monospace;
    margin: 0; padding: 0;
    display: flex; flex-direction: column; min-height: 100vh;
  }
  header {
    background: #b30000;
    padding: 12px 20px;
    text-align: center;
    font-size: 1.8rem;
    font-weight: bold;
    color: #fff;
    user-select: none;
  }
  main {
    flex: 1;
    padding: 15px 20px;
    display: flex;
    flex-direction: column;
    gap: 15px;
  }
  textarea#historico {
    width: 100%;
    min-height: 140px;
    background: #1c1c1c;
    border: 2px solid #b30000;
    border-radius: 6px;
    color: #eee;
    font-family: 'Share Tech Mono', monospace;
    font-size: 1rem;
    padding: 10px;
    resize: vertical;
  }
  button {
    background: #b30000;
    border: none;
    padding: 12px 20px;
    color: white;
    font-weight: 700;
    cursor: pointer;
    border-radius: 6px;
    font-family: 'Share Tech Mono', monospace;
    font-size: 1.1rem;
    transition: background-color 0.25s ease;
  }
  button:hover {
    background: #ff0000;
  }
  #resultado {
    background: #1a1a1a;
    border: 1px solid #b30000;
    border-radius: 6px;
    padding: 12px 15px;
    font-size: 1rem;
    min-height: 100px;
    white-space: pre-wrap;
    overflow-y: auto;
    color: #eee;
  }
  .btn-group {
    display: flex;
    gap: 10px;
    justify-content: center;
    margin-top: 10px;
  }
  .btn-sinal {
    flex: 1;
    background: #222;
    color: #b30000;
    border: 2px solid #b30000;
    font-weight: 700;
    user-select: none;
  }
  .btn-sinal.active {
    background: #b30000;
    color: #fff;
  }
  footer {
    padding: 10px;
    font-size: 0.85rem;
    text-align: center;
    color: #b30000;
    user-select: none;
  }
  .frase-scofield {
    margin-top: 15px;
    font-size: 1.25rem;
    color: #ff3333;
    font-weight: 700;
    text-align: center;
  }
</style>
</head>
<body>

<header>Scofield Analista — Plano Sombra</header>

<main>
  <label for="historico">Cole o histórico do jogo aqui (formato TipMiner):</label>
  <textarea id="historico" placeholder="Exemplo:\n14:22:00 — ⚫️ 5\n14:21:00 — 🔴 9\n14:20:00 — ⚪️ 0\n..."></textarea>
  
  <button id="btnAnalisar">Analisar</button>
  
  <div id="resultado" aria-live="polite" aria-atomic="true"></div>

  <div class="btn-group" role="group" aria-label="Sinais manuais para reforço">
    <button id="btnAnterior" class="btn-sinal" aria-pressed="false">Pedra Anterior</button>
    <button id="btnBranco" class="btn-sinal" aria-pressed="false">Branco</button>
    <button id="btnPosterior" class="btn-sinal" aria-pressed="false">Pedra Posterior</button>
  </div>

  <div class="frase-scofield" id="fraseScofield" aria-live="polite"></div>
</main>

<footer>© 2025 Scofield Analista</footer>

<script>
(() => {
  const historicoEl = document.getElementById('historico');
  const resultadoEl = document.getElementById('resultado');
  const btnAnalisar = document.getElementById('btnAnalisar');
  const fraseScofieldEl = document.getElementById('fraseScofield');
  const btnAnterior = document.getElementById('btnAnterior');
  const btnBranco = document.getElementById('btnBranco');
  const btnPosterior = document.getElementById('btnPosterior');

  // Estado dos sinais manuais
  let sinalManual = {
    anterior: false,
    branco: false,
    posterior: false
  };

  // Função para alternar botão sinal
  function toggleBtnSinal(btn, key) {
    sinalManual[key] = !sinalManual[key];
    btn.classList.toggle('active', sinalManual[key]);
    btn.setAttribute('aria-pressed', sinalManual[key]);
  }
  btnAnterior.addEventListener('click', () => toggleBtnSinal(btnAnterior, 'anterior'));
  btnBranco.addEventListener('click', () => toggleBtnSinal(btnBranco, 'branco'));
  btnPosterior.addEventListener('click', () => toggleBtnSinal(btnPosterior, 'posterior'));

  // Função para salvar e carregar localStorage
  function salvarLocal(data) {
    try {
      localStorage.setItem('planoSombraDados', JSON.stringify(data));
    } catch(e) {
      console.warn('Falha ao salvar localStorage', e);
    }
  }
  function carregarLocal() {
    try {
      const str = localStorage.getItem('planoSombraDados');
      if (!str) return null;
      return JSON.parse(str);
    } catch(e) {
      return null;
    }
  }

  // Converter emoji/color para texto cor
  function emojiParaCor(emoji) {
    if(!emoji) return null;
    if(emoji.includes('⚪')) return 'branco';
    if(emoji.includes('🔴')) return 'vermelho';
    if(emoji.includes('⚫')) return 'preto';
    return null;
  }

  // Parse do histórico colado para array de objetos {horario, cor, numero}
  function parseHistorico(texto) {
    const linhas = texto.trim().split('\n').filter(l => l.trim().length>0);
    const dados = [];
    for (const linha of linhas) {
      // Exemplo linha: "14:22:00 — ⚫️ 5" ou "14:22 — ⚫️ 5"
      // Separar por "—"
      const partes = linha.split('—');
      if(partes.length !== 2) continue;

      const horarioRaw = partes[0].trim();
      const corNumRaw = partes[1].trim();

      // Extraindo horário completo HH:mm:ss ou HH:mm
      let horario = null;
      if(/^\d{2}:\d{2}:\d{2}$/.test(horarioRaw)) {
        horario = horarioRaw;
      } else if(/^\d{2}:\d{2}$/.test(horarioRaw)) {
        horario = horarioRaw + ':00';
      } else {
        // horário inválido, pula linha
        continue;
      }

      // Agora separa cor e número
      // Cor é o emoji, número vem depois, exemplo: "⚫️ 5"
      const corMatch = corNumRaw.match(/[⚪🔴⚫]/);
      if(!corMatch) continue;
      const cor = emojiParaCor(corMatch[0]);

      const numeroStr = corNumRaw.replace(/[⚪🔴⚫️\s]/g, '').trim();
      const numero = parseInt(numeroStr, 10);
      if(isNaN(numero)) continue;

      dados.push({ horario, cor, numero });
    }
    return dados;
  }

  // Função para detectar brancos no histórico e relacionar com sinais manuais
  function detectarBrancos(dados, sinais) {
    // Cria uma lista dos índices de brancos no histórico
    const brancos = [];
    dados.forEach((item, idx) => {
      if(item.cor === 'branco') brancos.push(idx);
    });
    // Retorna objeto com brancos e suas pedras anterior/posterior informadas manualmente
    // Por padrão, usa as pedras anteriores/posteriores que o usuário marcou no botão manual
    return brancos.map(idx => {
      return {
        indice: idx,
        branco: dados[idx],
        anterior: sinais.anterior && idx > 0 ? dados[idx - 1] : null,
        posterior: sinais.posterior && idx < dados.length -1 ? dados[idx +1] : null
      };
    });
  }

  // Função para criar estratégias simples baseadas em soma e tempo entre brancos
  function analisarPadroes(dados, brancosComSinais) {
    // Estratégia 1: Soma das pedras anterior + posterior quando branco aparece
    // Estratégia 2: Intervalo de tempo médio entre brancos
    // Estratégia 3: Sequência repetida de cores antes do branco

    let resultado = '';

    if(brancosComSinais.length === 0) {
      resultado += 'Nenhum branco detectado com sinais manuais para análise.\n';
      return resultado;
    }

    // Soma anterior+posterior
    let somaTotal = 0, somaCount = 0;
    brancosComSinais.forEach(b => {
      if(b.anterior && b.posterior) {
        somaTotal += b.anterior.numero + b.posterior.numero;
        somaCount++;
      }
    });
    if(somaCount > 0) {
      const mediaSoma = somaTotal / somaCount;
      resultado += `🔴 Média da soma (anterior + posterior) para brancos: ${mediaSoma.toFixed(2)}\n`;
    } else {
      resultado += '⚠️ Sem dados suficientes para média de soma anterior + posterior.\n';
    }

    // Intervalo de tempo médio entre brancos
    if(brancosComSinais.length > 1) {
      let totalSegundos = 0, intervalosCount = 0;
      for(let i=1; i<brancosComSinais.length; i++) {
        const t1 = brancosComSinais[i-1].branco.horario;
        const t2 = brancosComSinais[i].branco.horario;
        const seg1 = toSeconds(t1);
        const seg2 = toSeconds(t2);
        totalSegundos += (seg1 > seg2) ? (86400 - seg1 + seg2) : (seg2 - seg1); // considera dia virando
        intervalosCount++;
      }
      const mediaIntervalo = totalSegundos / intervalosCount;
      resultado += `⏱️ Intervalo médio entre brancos: ${formatSegundos(mediaIntervalo)}\n`;
    } else {
      resultado += '⚠️ Intervalos de tempo insuficientes para análise.\n';
    }

    // Sequência de cores antes do branco (últimas 3 pedras antes do branco)
    const seqs = {};
    brancosComSinais.forEach(b => {
      const idx = b.indice;
      if(idx < 3) return;
      const seq = dados.slice(idx-3, idx).map(d => d.cor).join('-');
      seqs[seq] = (seqs[seq] || 0) + 1;
    });
    const seqsOrdenadas = Object.entries(seqs).sort((a,b) => b[1]-a[1]);
    if(seqsOrdenadas.length > 0) {
      resultado += '🎯 Sequências mais frequentes antes do branco:\n';
      seqsOrdenadas.slice(0,3).forEach(([seq, count]) => {
        resultado += `- ${seq.replace(/-/g, ' → ')} (ocorreu ${count}x)\n`;
      });
    } else {
      resultado += '⚠️ Não foram encontradas sequências suficientes para análise.\n';
    }

    return resultado;
  }

  // Converte horário "HH:mm:ss" para segundos do dia
  function toSeconds(horaStr) {
    const [h,m,s] = horaStr.split(':').map(x => parseInt(x,10));
    return h*3600 + m*60 + s;
  }
  // Formata segundos para "mm:ss"
  function formatSegundos(seg) {
    const m = Math.floor(seg/60);
    const s = Math.floor(seg%60);
    return `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
  }

  // Função principal ao clicar em Analisar
  function analisar() {
    fraseScofieldEl.textContent = '';
    resultadoEl.textContent = '';
    const texto = historicoEl.value;
    if(!texto.trim()) {
      resultadoEl.textContent = '⚠️ Cole o histórico antes de analisar.';
      return;
    }

    const dados = parseHistorico(texto);
    if(dados.length === 0) {
      resultadoEl.textContent = '⚠️ Histórico inválido ou sem dados válidos.';
      return;
    }

    // Detectar brancos usando sinais manuais
    const brancosComSinais = detectarBrancos(dados, sinalManual);

    // Salvar tudo localmente
    salvarLocal({historico:texto, sinais:sinalManual});

    // Analisar padrões
    const analise = analisarPadroes(dados, brancosComSinais);

    resultadoEl.textContent = analise;

    // Se algum padrão relevante (ex: média soma entre 10 e 20), ativar frase Scofield
    if(analise.includes('Média da soma')) {
      fraseScofieldEl.textContent = 'Se você estiver lendo isso... o plano já começou.';
      // Aqui pode tocar um som de alerta (se quiser implementar)
    }
  }

  // Carregar dados salvos ao iniciar
  function carregar() {
    const salvo = carregarLocal();
    if(salvo) {
      historicoEl.value = salvo.historico || '';
      sinalManual = salvo.sinais || {anterior:false, branco:false, posterior:false};
      [btnAnterior, btnBranco, btnPosterior].forEach((btn, i) => {
        const key = ['anterior', 'branco', 'posterior'][i];
        if(sinalManual[key]) {
          btn.classList.add('active');
          btn.setAttribute('aria-pressed', 'true');
        } else {
          btn.classList.remove('active');
          btn.setAttribute('aria-pressed', 'false');
        }
      });
      if(historicoEl.value.trim()) {
        analisar();
      }
    }
  }

  btnAnalisar.addEventListener('click', analisar);

  carregar();
})();
</script>

</body>
</html>
